{
    "contents" : "## microfinance network \n## data from BANERJEE, CHANDRASEKHAR, DUFLO, JACKSON 2012\n\n## data on 8622 households\nhh <- read.csv(\"microfi_households.csv\", row.names=\"hh\")\nhh$village <- factor(hh$village)\n\n## We'll kick off with a bunch of network stuff.\n## This will be covered in more detail in lecture 6.\n## get igraph off of CRAN if you don't have it\n## install.packages(\"igraph\")\n## this is a tool for network analysis\n## (see http://igraph.sourceforge.net/)\nlibrary(igraph)\nedges <- read.table(\"microfi_edges.txt\", colClasses=\"character\")\n## edges holds connections between the household ids\nhhnet <- graph.edgelist(as.matrix(edges))\nhhnet <- as.undirected(hhnet) # two-way connections.\n\n## igraph is all about plotting.  \nV(hhnet) ## our 8000+ household vertices\n## Each vertex (node) has some attributes, and we can add more.\nV(hhnet)$village <- as.character(hh[V(hhnet),'village'])\n## we'll color them by village membership\nvilcol <- rainbow(nlevels(hh$village))\nnames(vilcol) <- levels(hh$village)\nV(hhnet)$color = vilcol[V(hhnet)$village]\n## drop HH labels from plot\nV(hhnet)$label=NA\n\n# graph plots try to force distances proportional to connectivity\n# imagine nodes connected by elastic bands that you are pulling apart\n# The graphs can take a very long time, but I've found\n# edge.curved=FALSE speeds things up a lot.  Not sure why.\n\n## we'll use induced.subgraph and plot a couple villages \nvillage1 <- induced.subgraph(hhnet, v=which(V(hhnet)$village==\"1\"))\nvillage33 <- induced.subgraph(hhnet, v=which(V(hhnet)$village==\"33\"))\n\n# vertex.size=3 is small.  default is 15\nplot(village1, vertex.size=3, edge.curved=FALSE)\nplot(village33, vertex.size=3, edge.curved=FALSE)\n\n######  now, on to your homework stuff\n\nlibrary(gamlr)\n\n## match id's; I call these 'zebras' because they are like crosswalks\nzebra <- match(rownames(hh), V(hhnet)$name)\n\n## calculate the `degree' of each hh: \n##  number of commerce/friend/family connections\ndegree <- degree(hhnet)[zebra]\nnames(degree) <- rownames(hh)\ndegree[is.na(degree)] <- 0 # unconnected houses, not in our graph\n\n## if you run a full glm, it takes forever and is an overfit mess\n# > summary(full <- glm(loan ~ degree + .^2, data=hh, family=\"binomial\"))\n# Warning messages:\n# 1: glm.fit: algorithm did not converge \n# 2: glm.fit: fitted probabilities numerically 0 or 1 occurred \n\n\n##[1] I'd transform degree to create our treatment variable d. What would you do and why?\nd  <- log(degree)\n\n#I would transform d into Log(d) because we are ultimately wanting to find percentage change in number of networks that affects odds of getting a loan.\n\n##[2] Build a model to predict d from x, our controls. Comment on how tight the fit is, and what that implies for estimation of a treatment effect.\n\nloanControls  <- glm(hh$loan ~ hh$village + hh$religion + hh$roof + hh$rooms + hh$beds + hh$electricity + hh$ownership + hh$leader )\n\n##[3] Use predictions from [2] in an estimator for effect of d on loan.\n\n##[4] Compare the results from [3] to those from a straight (naive) lasso for loan on d and x. Explain why they are similar or different.\n\n##[5] Bootstrap your estimator from [3] and describe the uncertainty.\n\n##[+] Can you think of how you'd design an experiment to estimate the treatment effect of network degree?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1430324627574.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "342730968",
    "id" : "862EE526",
    "lastKnownWriteTime" : 1430326922,
    "path" : "C:/Users/Eddie/Google Drive/Academics/Big Data/4/HW4/microfi_start.R",
    "project_path" : "microfi_start.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}